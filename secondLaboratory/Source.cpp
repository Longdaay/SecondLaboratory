#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;
int main()
{
	unsigned short n; // переменная, которая хранит размерность массива
	int* digits_array; // объявление массива для чисел
	int temp; // переменная, которая, во время сортировки массива, хранит временное значение элемента
	int min_value; // переменная, которая принимает минимальное значение во время сортировки
	int j = 0; // объявление переменной, которая используется для выбора иного от i элемента массива
	short value_a; // переменная, в которую пользователь вводит значение для проверки
	int count = 0; // переменная, которая хранит количество чисел удовлетворяющих условию
	clock_t start; // переменная, в которую записывается время старта события
	clock_t end; // переменная, в которую записывается время окончания события
	double seconds; // переменная, которая хранит в себе время исполнения события

	// вводим значение размерности массива
	cout << "Enter the N" << endl;
	cin >> n;
	digits_array = new int[n]; // задаем массиву размерность N

	// выводим получившийся массив
	cout << endl << "Array:" << endl;
	// 
	srand(time(0)); // устанавливает передаваемое пользователем значение в качестве стартового. Получает на вход в виде параметра системное время, которое при каждом запуске программы будет разным. Позволяет rand() каждый раз генерировать случайные числа

	for (int i = 0; i < n; i++) // цикл для генерации цифр и звписи в
	{
		digits_array[i] = rand() % 100; // генерируем элемент массива и загоняем значение в диапазон от 0 до 99
		cout << digits_array[i] << " "; // выводим через пробел
	}
	cout << endl << "Enough!" << endl << endl;
	cout << "Sort array: " << endl;
	start = clock(); // устанавливаем начало отсчета времени события
	// сортируем массив вставками insertion sort
	for (int i = 1; i < n; i++)
	{
		min_value = digits_array[i]; // задаем текущему минимальному значению массива текущий элемент массива
		j = i - 1; // задаем значению j на 1 меньше, чем i, для того, чтобы работать с предыдущем элемнентом массива 
		while (j >= 0 and digits_array[j] > min_value) //пока текущий элемент меньше предыдущего и j не присвоила отрицательное значение, присваиваем последующему значению предыдущее ???
		{
			digits_array[j + 1] = digits_array[j];
			j = j - 1;
		}
		digits_array[j + 1] = min_value; // присыаиваем ???
	}
	end = clock(); // устанавливаем конец отсчета времени события
	seconds = (double)(end - start) / (double)CLOCKS_PER_SEC; // присваиваем значению время, потраченное на сортировку массива

	// выводим отсортированный массив
	for (int i = 0; i < n; i++)
	{
		cout << digits_array[i] << " ";
	}
	cout << endl << endl;
	cout << "Time sort: " << seconds << " seconds" << endl << endl;
	// указываем минимальное и максимальное значения массива
	cout << "manimum value in array: " << digits_array[0] << endl;
	cout << "maximum value in array: " << digits_array[n - 1] << endl << endl;

	// вводим значение для подсчета количества элементов массива, не превышающих заданное значение
	cout << "Enter the digit: ";
	cin >> value_a; // сделатт защиту от дурака
	for (int i = 0; i < n; i++) // прогоняем весь массив и подсчитываем количество элементов
	{
		if (digits_array[i] < value_a)
		{
			count++;
		}
	}
	// выводим полученное количество
	cout << "count whos < " << value_a << ": " << count << endl;

	// вводим значение для подсчета кодичества эдементов, превышающих заданное значение
	cout << "Try to write another one value: ";

	cin >> value_a; // объединить циклы в один
	count = 0; // обнуляем "счетчик" для повторного ичпользования 
	for (int i = 0; i < n; i++) // прогоняем весь массив и подсчитываем количество элементов
	{
		if (digits_array[i] > value_a)
		{
			count++;
		}
	}
	// выводим полученное количество
	cout << "count whos > " << value_a << ": " << count << endl;

	// очищаем память от массива
	delete[] digits_array;
	// что б задать рандомный неповторяющийся номер элемента массива, надо сравнить каждый получаемый элемент с остальными и, если он не подходит, то генерировать заново 
	return 0;
}